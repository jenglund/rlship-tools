
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>models: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jenglund/rlship-tools/internal/models/activity.go (100.0%)</option>
				
				<option value="file1">github.com/jenglund/rlship-tools/internal/models/activity_photo.go (100.0%)</option>
				
				<option value="file2">github.com/jenglund/rlship-tools/internal/models/errors.go (100.0%)</option>
				
				<option value="file3">github.com/jenglund/rlship-tools/internal/models/list.go (99.0%)</option>
				
				<option value="file4">github.com/jenglund/rlship-tools/internal/models/sync.go (93.8%)</option>
				
				<option value="file5">github.com/jenglund/rlship-tools/internal/models/tribe.go (100.0%)</option>
				
				<option value="file6">github.com/jenglund/rlship-tools/internal/models/types.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package models

import (
        "fmt"
        "time"

        "github.com/google/uuid"
)

// ActivityType represents the type of activity (location, interest, list, etc.)
type ActivityType string

const (
        ActivityTypeLocation ActivityType = "location"
        ActivityTypeInterest ActivityType = "interest"
        ActivityTypeList     ActivityType = "list"
        ActivityTypeActivity ActivityType = "activity"
        ActivityTypeEvent    ActivityType = "event"
)

// Activity represents any type of activity, interest, location, or list
type Activity struct {
        ID          uuid.UUID      `json:"id" db:"id"`
        UserID      uuid.UUID      `json:"user_id" db:"user_id"`
        Type        ActivityType   `json:"type" db:"type"`
        Name        string         `json:"name" db:"name"`
        Description string         `json:"description" db:"description"`
        Visibility  VisibilityType `json:"visibility" db:"visibility"`
        Metadata    JSONMap        `json:"metadata,omitempty" db:"metadata"`
        CreatedAt   time.Time      `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time      `json:"updated_at" db:"updated_at"`
        DeletedAt   *time.Time     `json:"deleted_at,omitempty" db:"deleted_at"`
}

// ActivityOwner represents an owner (user or tribe) of an activity
type ActivityOwner struct {
        ActivityID uuid.UUID  `json:"activity_id" db:"activity_id"`
        OwnerID    uuid.UUID  `json:"owner_id" db:"owner_id"`
        OwnerType  OwnerType  `json:"owner_type" db:"owner_type"`
        CreatedAt  time.Time  `json:"created_at" db:"created_at"`
        DeletedAt  *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// ActivityShare represents a shared activity with a tribe
type ActivityShare struct {
        ActivityID uuid.UUID  `json:"activity_id" db:"activity_id"`
        TribeID    uuid.UUID  `json:"tribe_id" db:"tribe_id"`
        UserID     uuid.UUID  `json:"user_id" db:"user_id"`
        CreatedAt  time.Time  `json:"created_at" db:"created_at"`
        ExpiresAt  *time.Time `json:"expires_at,omitempty" db:"expires_at"`
        DeletedAt  *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// ActivityRepository defines the interface for activity data operations
type ActivityRepository interface {
        Create(activity *Activity) error
        GetByID(id uuid.UUID) (*Activity, error)
        Update(activity *Activity) error
        Delete(id uuid.UUID) error
        List(offset, limit int) ([]*Activity, error)

        // Owner management
        AddOwner(activityID, ownerID uuid.UUID, ownerType OwnerType) error
        RemoveOwner(activityID, ownerID uuid.UUID) error
        GetOwners(activityID uuid.UUID) ([]*ActivityOwner, error)
        GetUserActivities(userID uuid.UUID) ([]*Activity, error)
        GetTribeActivities(tribeID uuid.UUID) ([]*Activity, error)

        // Sharing management
        ShareWithTribe(activityID, tribeID, userID uuid.UUID, expiresAt *time.Time) error
        UnshareWithTribe(activityID, tribeID uuid.UUID) error
        GetSharedActivities(tribeID uuid.UUID) ([]*Activity, error)

        // Cleanup
        MarkForDeletion(activityID uuid.UUID) error
        CleanupOrphanedActivities() error
}

// Validate ensures the activity data is valid
func (a *Activity) Validate() error <span class="cov8" title="1">{
        if a.ID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: activity ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if a.UserID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: user ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if a.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: name is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if err := a.Visibility.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if a.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: created_at is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if a.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: updated_at is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if a.DeletedAt != nil &amp;&amp; a.DeletedAt.Before(a.CreatedAt) </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: deleted_at cannot be before created_at", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package models

import (
        "github.com/google/uuid"
)

// ActivityPhoto represents a photo associated with an activity
type ActivityPhoto struct {
        BaseModel
        ActivityID uuid.UUID `json:"activity_id"`
        URL        string    `json:"url"`
        Caption    string    `json:"caption"`
        Metadata   JSONMap   `json:"metadata"`
}

// Validate ensures the activity photo data is valid
func (p *ActivityPhoto) Validate() error <span class="cov8" title="1">{
        if err := p.BaseModel.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if p.ActivityID == uuid.Nil </span><span class="cov8" title="1">{
                return ErrInvalidActivityID
        }</span>
        <span class="cov8" title="1">if p.URL == "" </span><span class="cov8" title="1">{
                return ErrInvalidURL
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package models

import "errors"

// Common errors
var (
        ErrNotFound     = errors.New("not found")
        ErrInvalidInput = errors.New("invalid input")
        ErrUnauthorized = errors.New("unauthorized")
        ErrForbidden    = errors.New("forbidden")
        ErrDuplicate    = errors.New("duplicate")
)

// Sync-specific errors
var (
        // Configuration errors
        ErrInvalidSyncConfig = errors.New("invalid sync configuration")
        ErrInvalidSyncSource = errors.New("invalid sync source")
        ErrMissingSyncID     = errors.New("missing sync ID")
        ErrInvalidSyncStatus = errors.New("invalid sync status")

        // State transition errors
        ErrInvalidSyncTransition = errors.New("invalid sync state transition")
        ErrSyncDisabled          = errors.New("sync is disabled")
        ErrSyncAlreadyEnabled    = errors.New("sync is already enabled")

        // Conflict errors
        ErrConflictNotFound        = errors.New("sync conflict not found")
        ErrConflictAlreadyResolved = errors.New("sync conflict already resolved")
        ErrInvalidResolution       = errors.New("invalid conflict resolution")

        // External source errors
        ErrExternalSourceUnavailable = errors.New("external sync source unavailable")
        ErrExternalSourceError       = errors.New("external sync source error")
        ErrExternalSourceTimeout     = errors.New("external sync source timeout")

        // ErrConcurrentModification is returned when a concurrent modification is detected
        ErrConcurrentModification = errors.New("concurrent modification detected")
)

// Activity Photo errors
var (
        ErrInvalidID         = errors.New("invalid ID")
        ErrInvalidActivityID = errors.New("invalid activity ID")
        ErrInvalidURL        = errors.New("invalid URL")
        ErrInvalidCreatedAt  = errors.New("invalid created at time")
        ErrInvalidUpdatedAt  = errors.New("invalid updated at time")
        ErrInvalidDeletedAt  = errors.New("deleted at time cannot be before created at time")
)

// IsSyncError checks if an error is a sync-related error
func IsSyncError(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, ErrInvalidSyncConfig) ||
                errors.Is(err, ErrInvalidSyncSource) ||
                errors.Is(err, ErrMissingSyncID) ||
                errors.Is(err, ErrInvalidSyncStatus) ||
                errors.Is(err, ErrInvalidSyncTransition) ||
                errors.Is(err, ErrSyncDisabled) ||
                errors.Is(err, ErrSyncAlreadyEnabled) ||
                errors.Is(err, ErrConflictNotFound) ||
                errors.Is(err, ErrConflictAlreadyResolved) ||
                errors.Is(err, ErrInvalidResolution) ||
                errors.Is(err, ErrExternalSourceUnavailable) ||
                errors.Is(err, ErrExternalSourceError) ||
                errors.Is(err, ErrExternalSourceTimeout)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// ListType represents the type of list
type ListType string

const (
        ListTypeGeneral   ListType = "general"
        ListTypeLocation  ListType = "location"
        ListTypeActivity  ListType = "activity"
        ListTypeInterest  ListType = "interest"
        ListTypeGoogleMap ListType = "google_map"
)

func (lt ListType) Validate() error <span class="cov8" title="1">{
        switch lt </span>{
        case ListTypeGeneral, ListTypeLocation, ListTypeActivity, ListTypeInterest, ListTypeGoogleMap:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: invalid list type: %s", ErrInvalidInput, lt)</span>
        }
}

// ListSyncStatus represents the sync status of a list
type ListSyncStatus string

const (
        ListSyncStatusNone     ListSyncStatus = "none"
        ListSyncStatusPending  ListSyncStatus = "pending"
        ListSyncStatusSynced   ListSyncStatus = "synced"
        ListSyncStatusConflict ListSyncStatus = "conflict"
)

func (ls ListSyncStatus) Validate() error <span class="cov8" title="1">{
        switch ls </span>{
        case ListSyncStatusNone, ListSyncStatusSynced, ListSyncStatusPending, ListSyncStatusConflict:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: invalid sync status: %s", ErrInvalidInput, ls)</span>
        }
}

// List represents a list in the system
type List struct {
        ID            uuid.UUID      `json:"id" db:"id"`
        Type          ListType       `json:"type" db:"type"`
        Name          string         `json:"name" db:"name"`
        Description   string         `json:"description" db:"description"`
        Visibility    VisibilityType `json:"visibility" db:"visibility"`
        SyncConfig    *SyncConfig    `json:"-" db:"-"`                     // Internal sync configuration
        SyncStatus    ListSyncStatus `json:"sync_status" db:"sync_status"` // Denormalized for querying
        SyncSource    SyncSource     `json:"sync_source" db:"sync_source"` // Denormalized for querying
        SyncID        string         `json:"sync_id" db:"sync_id"`         // Denormalized for querying
        LastSyncAt    *time.Time     `json:"last_sync_at" db:"last_sync_at"`
        DefaultWeight float64        `json:"default_weight" db:"default_weight"`
        MaxItems      *int           `json:"max_items" db:"max_items"`
        CooldownDays  *int           `json:"cooldown_days" db:"cooldown_days"`
        CreatedAt     time.Time      `json:"created_at" db:"created_at"`
        UpdatedAt     time.Time      `json:"updated_at" db:"updated_at"`
        DeletedAt     *time.Time     `json:"deleted_at,omitempty" db:"deleted_at"`
        Items         []*ListItem    `json:"items,omitempty" db:"-"`
        Owners        []*ListOwner   `json:"owners,omitempty" db:"-"`
        Shares        []*ListShare   `json:"shares,omitempty" db:"-"`

        // Owner fields for creation/update operations
        OwnerID   *uuid.UUID `json:"owner_id,omitempty" db:"-"`
        OwnerType *OwnerType `json:"owner_type,omitempty" db:"-"`
}

// Validate performs validation on the List
func (l *List) Validate() error <span class="cov8" title="1">{
        if l.ID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: list ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if err := l.Type.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := l.Visibility.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate sync configuration
        <span class="cov8" title="1">if l.SyncConfig != nil </span><span class="cov8" title="1">{
                if err := l.SyncConfig.Validate(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // Ensure denormalized fields match the config
                <span class="cov8" title="1">if l.SyncStatus != l.SyncConfig.Status </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync status mismatch", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if l.SyncSource != l.SyncConfig.Source </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync source mismatch", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if l.SyncID != l.SyncConfig.ID </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync ID mismatch", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if !((l.LastSyncAt == nil &amp;&amp; l.SyncConfig.LastSyncAt == nil) ||
                        (l.LastSyncAt != nil &amp;&amp; l.SyncConfig.LastSyncAt != nil &amp;&amp; l.LastSyncAt.Equal(*l.SyncConfig.LastSyncAt))) </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: last sync time mismatch", ErrInvalidInput)
                }</span>
        } else<span class="cov8" title="1"> {
                // If no sync config, ensure sync fields are in their default state
                if l.SyncStatus != ListSyncStatusNone </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync status must be none when no config is present", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if l.SyncSource != SyncSourceNone </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync source must be none when no config is present", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if l.SyncID != "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync ID must be empty when no config is present", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if l.LastSyncAt != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: last sync time must be empty when no config is present", ErrInvalidInput)
                }</span>
        }

        <span class="cov8" title="1">if l.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: list name is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.DefaultWeight &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: default weight must be positive", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.MaxItems != nil &amp;&amp; *l.MaxItems &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: max items must be positive", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.CooldownDays != nil &amp;&amp; *l.CooldownDays &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: cooldown days cannot be negative", ErrInvalidInput)
        }</span>

        // Validate owner fields if provided
        <span class="cov8" title="1">if l.OwnerID != nil &amp;&amp; l.OwnerType == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: owner type is required when owner ID is provided", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.OwnerID == nil &amp;&amp; l.OwnerType != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: owner ID is required when owner type is provided", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.OwnerType != nil </span><span class="cov8" title="1">{
                if err := l.OwnerType.Validate(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ListItem represents an item in a list
type ListItem struct {
        ID          uuid.UUID    `json:"id" db:"id"`
        ListID      uuid.UUID    `json:"list_id" db:"list_id"`
        Name        string       `json:"name" db:"name"`
        Description string       `json:"description" db:"description"`
        Metadata    Metadata     `json:"metadata,omitempty" db:"metadata"`
        ExternalID  string       `json:"external_id,omitempty" db:"external_id"`
        Latitude    *float64     `json:"latitude,omitempty" db:"latitude"`
        Longitude   *float64     `json:"longitude,omitempty" db:"longitude"`
        Address     *string      `json:"address,omitempty" db:"address"`
        Location    *LocationRef `json:"location,omitempty" db:"-"`
        Weight      float64      `json:"weight" db:"weight"`
        LastChosen  *time.Time   `json:"last_chosen" db:"last_chosen"`
        ChosenCount int          `json:"chosen_count" db:"chosen_count"`
        LastUsed    *time.Time   `json:"last_used" db:"last_used"`
        UseCount    int          `json:"use_count" db:"use_count"`
        Cooldown    *int         `json:"cooldown" db:"cooldown"`
        Available   bool         `json:"available" db:"available"`
        Seasonal    bool         `json:"seasonal" db:"seasonal"`
        StartDate   *time.Time   `json:"start_date" db:"start_date"`
        EndDate     *time.Time   `json:"end_date" db:"end_date"`
        CreatedAt   time.Time    `json:"created_at" db:"created_at"`
        UpdatedAt   time.Time    `json:"updated_at" db:"updated_at"`
        DeletedAt   *time.Time   `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Validate performs validation on the ListItem
func (li *ListItem) Validate() error <span class="cov8" title="1">{
        if li.ID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: item ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if li.ListID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: list ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if li.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: item name is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if li.Weight &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: weight must be positive", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if li.Cooldown != nil &amp;&amp; *li.Cooldown &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: cooldown cannot be negative", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if li.Seasonal </span><span class="cov8" title="1">{
                if li.StartDate == nil || li.EndDate == nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: seasonal items must have start and end dates", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if li.StartDate.After(*li.EndDate) </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: start date must be before end date", ErrInvalidInput)
                }</span>
        }
        <span class="cov8" title="1">if li.Latitude != nil &amp;&amp; (li.Longitude == nil || li.Address == nil) </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: location requires latitude, longitude, and address", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// LocationRef represents a reference to a location
type LocationRef struct {
        Latitude  float64 `json:"latitude"`
        Longitude float64 `json:"longitude"`
        Address   string  `json:"address"`
        PlaceID   string  `json:"place_id,omitempty"`
}

// Validate performs validation on the LocationRef
func (l *LocationRef) Validate() error <span class="cov8" title="1">{
        if l.Latitude &lt; -90 || l.Latitude &gt; 90 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: latitude must be between -90 and 90", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.Longitude &lt; -180 || l.Longitude &gt; 180 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: longitude must be between -180 and 180", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.Address == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: address is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Metadata represents additional data for a list item
type Metadata = JSONMap

// Validate performs validation on the Metadata
func (m Metadata) Validate() error <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Ensure metadata can be marshaled to JSON
        <span class="cov8" title="1">bytes, err := json.Marshal(m)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: invalid metadata: %v", ErrInvalidInput, err)
        }</span>

        // Check if the metadata is too large (&gt; 50KB)
        <span class="cov8" title="1">const maxSize = 50 * 1024 // 50KB
        if len(bytes) &gt; maxSize </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: metadata size exceeds maximum allowed size of 50KB", ErrInvalidInput)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ListOwner represents an owner of a list
type ListOwner struct {
        ListID    uuid.UUID  `json:"list_id" db:"list_id"`
        OwnerID   uuid.UUID  `json:"owner_id" db:"owner_id"`
        OwnerType OwnerType  `json:"owner_type" db:"owner_type"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt time.Time  `json:"updated_at" db:"updated_at"`
        DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}

// Validate performs validation on the ListOwner
func (lo *ListOwner) Validate() error <span class="cov8" title="1">{
        if lo.ListID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: list ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if lo.OwnerID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: owner ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if err := lo.OwnerType.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ListShare represents a shared list with a tribe
type ListShare struct {
        ListID    uuid.UUID  `json:"list_id" db:"list_id"`
        TribeID   uuid.UUID  `json:"tribe_id" db:"tribe_id"`
        UserID    uuid.UUID  `json:"user_id" db:"user_id"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt time.Time  `json:"updated_at" db:"updated_at"`
        ExpiresAt *time.Time `json:"expires_at,omitempty" db:"expires_at"`
        DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
        Version   int        `json:"version" db:"version"`
}

// Validate performs validation on the ListShare
func (ls *ListShare) Validate() error <span class="cov8" title="1">{
        if ls.ListID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: list ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if ls.TribeID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: tribe ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if ls.UserID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: user ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if ls.ExpiresAt != nil &amp;&amp; ls.ExpiresAt.Before(time.Now()) </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: expiration date must be in the future", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ListRepository defines the interface for list storage operations
type ListRepository interface {
        // Basic CRUD operations
        Create(list *List) error
        GetByID(id uuid.UUID) (*List, error)
        Update(list *List) error
        Delete(id uuid.UUID) error
        List(offset, limit int) ([]*List, error)

        // List item operations
        AddItem(item *ListItem) error
        UpdateItem(item *ListItem) error
        RemoveItem(listID, itemID uuid.UUID) error
        GetItems(listID uuid.UUID) ([]*ListItem, error)
        GetEligibleItems(listIDs []uuid.UUID, filters map[string]interface{}) ([]*ListItem, error)
        UpdateItemStats(itemID uuid.UUID, chosen bool) error
        MarkItemChosen(itemID uuid.UUID) error

        // Owner management
        AddOwner(owner *ListOwner) error
        RemoveOwner(listID, ownerID uuid.UUID) error
        GetOwners(listID uuid.UUID) ([]*ListOwner, error)
        GetUserLists(userID uuid.UUID) ([]*List, error)
        GetTribeLists(tribeID uuid.UUID) ([]*List, error)
        GetListsByOwner(ownerID uuid.UUID, ownerType OwnerType) ([]*List, error)

        // Share management
        ShareWithTribe(share *ListShare) error
        UnshareWithTribe(listID, tribeID uuid.UUID) error
        GetSharedLists(tribeID uuid.UUID) ([]*List, error)
        GetSharedTribes(listID uuid.UUID) ([]*Tribe, error)
        GetListShares(listID uuid.UUID) ([]*ListShare, error)

        // Sync management
        UpdateSyncStatus(listID uuid.UUID, status ListSyncStatus) error
        GetConflicts(listID uuid.UUID) ([]*SyncConflict, error)
        CreateConflict(conflict *SyncConflict) error
        ResolveConflict(conflictID uuid.UUID) error
        GetListsBySource(source string) ([]*List, error)
        AddConflict(conflict *SyncConflict) error
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "fmt"
        "time"

        "github.com/google/uuid"
)

// SyncSource represents a supported external sync source
type SyncSource string

const (
        SyncSourceNone       SyncSource = "none"
        SyncSourceGoogleMaps SyncSource = "google_maps"
        SyncSourceManual     SyncSource = "manual"
        SyncSourceImported   SyncSource = "imported"
)

// Validate checks if the sync source is valid
func (s SyncSource) Validate() error <span class="cov8" title="1">{
        switch s </span>{
        case SyncSourceNone, SyncSourceGoogleMaps, SyncSourceManual, SyncSourceImported:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: invalid sync source: %s", ErrInvalidInput, s)</span>
        }
}

// SyncTransition represents a valid state transition in the sync state machine
type SyncTransition struct {
        From   ListSyncStatus
        To     ListSyncStatus
        Action string
}

// ValidSyncTransitions defines all valid state transitions
var ValidSyncTransitions = []SyncTransition{
        {From: ListSyncStatusNone, To: ListSyncStatusPending, Action: "configure_sync"},
        {From: ListSyncStatusPending, To: ListSyncStatusSynced, Action: "sync_complete"},
        {From: ListSyncStatusPending, To: ListSyncStatusConflict, Action: "conflict_detected"},
        {From: ListSyncStatusSynced, To: ListSyncStatusPending, Action: "local_change"},
        {From: ListSyncStatusSynced, To: ListSyncStatusConflict, Action: "remote_change_conflict"},
        {From: ListSyncStatusConflict, To: ListSyncStatusPending, Action: "resolve_conflict"},
        {From: ListSyncStatusConflict, To: ListSyncStatusSynced, Action: "auto_resolve"},
        {From: ListSyncStatusPending, To: ListSyncStatusNone, Action: "disable_sync"},
        {From: ListSyncStatusSynced, To: ListSyncStatusNone, Action: "disable_sync"},
        {From: ListSyncStatusConflict, To: ListSyncStatusNone, Action: "disable_sync"},
}

// SyncConfig represents the sync configuration for a list
type SyncConfig struct {
        Source     SyncSource     `json:"source" db:"sync_source"`
        ID         string         `json:"id" db:"sync_id"`
        Status     ListSyncStatus `json:"status" db:"sync_status"`
        LastSyncAt *time.Time     `json:"last_sync_at" db:"last_sync_at"`
}

// Validate performs validation on the sync configuration
func (sc *SyncConfig) Validate() error <span class="cov8" title="1">{
        if err := sc.Source.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := sc.Status.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate sync source specific rules
        <span class="cov8" title="1">switch sc.Source </span>{
        case SyncSourceGoogleMaps:<span class="cov8" title="1">
                if sc.ID == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: Google Maps sync requires a valid place ID", ErrInvalidInput)
                }</span>
        case SyncSourceNone:<span class="cov8" title="1">
                if sc.Status != ListSyncStatusNone </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync status must be none when no source is configured", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if sc.ID != "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: sync ID must be empty when no source is configured", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if sc.LastSyncAt != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: last sync time must be empty when no source is configured", ErrInvalidInput)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateTransition checks if a sync status transition is valid
func ValidateTransition(from, to ListSyncStatus, action string) error <span class="cov8" title="1">{
        for _, t := range ValidSyncTransitions </span><span class="cov8" title="1">{
                if t.From == from &amp;&amp; t.To == to &amp;&amp; t.Action == action </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("invalid transition from '%s' to '%s' with action '%s'",
                from, to, action)</span>
}

// SyncConflict represents a sync conflict that needs resolution
type SyncConflict struct {
        ID         uuid.UUID   `json:"id" db:"id"`
        ListID     uuid.UUID   `json:"list_id" db:"list_id"`
        ItemID     *uuid.UUID  `json:"item_id,omitempty" db:"item_id"`
        Type       string      `json:"type" db:"type"`
        LocalData  interface{} `json:"local_data" db:"local_data"`
        RemoteData interface{} `json:"remote_data" db:"remote_data"`
        Resolution string      `json:"resolution" db:"resolution"`
        CreatedAt  time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt  time.Time   `json:"updated_at" db:"updated_at"`
        ResolvedAt *time.Time  `json:"resolved_at,omitempty" db:"resolved_at"`
}

// Validate performs validation on the sync conflict
func (sc *SyncConflict) Validate() error <span class="cov8" title="1">{
        if sc.ID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: conflict ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if sc.ListID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: list ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if sc.Type == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: conflict type is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if sc.LocalData == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: local data is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if sc.RemoteData == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: remote data is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// TribeType represents the type of tribe
type TribeType string

const (
        TribeTypeCouple    TribeType = "couple"    // Two-person romantic relationship
        TribeTypePolyCule  TribeType = "polycule"  // Polyamorous relationship group
        TribeTypeFriends   TribeType = "friends"   // Friend group
        TribeTypeFamily    TribeType = "family"    // Family group
        TribeTypeRoommates TribeType = "roommates" // Roommate group
        TribeTypeCoworkers TribeType = "coworkers" // Work team or group
        TribeTypeCustom    TribeType = "custom"    // Custom group type
)

func (t TribeType) Validate() error <span class="cov8" title="1">{
        switch t </span>{
        case TribeTypeCouple, TribeTypePolyCule, TribeTypeFriends, TribeTypeFamily,
                TribeTypeRoommates, TribeTypeCoworkers, TribeTypeCustom:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: invalid tribe type: %s", ErrInvalidInput, t)</span>
        }
}

// MembershipType represents the type of membership in a tribe
type MembershipType string

const (
        MembershipFull    MembershipType = "full"    // Full member with all privileges
        MembershipLimited MembershipType = "limited" // Limited access member
        MembershipGuest   MembershipType = "guest"   // Temporary guest access
)

func (m MembershipType) Validate() error <span class="cov8" title="1">{
        switch m </span>{
        case MembershipFull, MembershipLimited, MembershipGuest:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: invalid membership type: %s", ErrInvalidInput, m)</span>
        }
}

// Tribe represents a group of users who share activities and plans
type Tribe struct {
        BaseModel
        Name        string         `json:"name" db:"name"`
        Type        TribeType      `json:"type" db:"type"`
        Description string         `json:"description" db:"description"`
        Visibility  VisibilityType `json:"visibility" db:"visibility"`
        Metadata    JSONMap        `json:"metadata,omitempty" db:"metadata"`
        Members     []*TribeMember `json:"members,omitempty" db:"-"`
}

// Validate performs validation on the tribe
func (t *Tribe) Validate() error <span class="cov8" title="1">{
        if err := t.BaseModel.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if t.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: name is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if len(t.Name) &gt; 100 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: name cannot be longer than 100 characters", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if err := t.Type.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := t.Visibility.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Ensure metadata is never nil
        <span class="cov8" title="1">if t.Metadata == nil </span><span class="cov8" title="1">{
                t.Metadata = JSONMap{}
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for Tribe to ensure Metadata is never nil
func (t *Tribe) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Define an alias type to avoid infinite recursion
        type AliasType Tribe

        // Use a temporary structure with the same fields
        aux := struct {
                *AliasType
                Metadata *JSONMap `json:"metadata,omitempty"`
        }{
                AliasType: (*AliasType)(t),
        }

        // Unmarshal JSON into the temporary structure
        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Initialize empty metadata if it's nil
        <span class="cov8" title="1">if aux.Metadata == nil </span><span class="cov8" title="1">{
                t.Metadata = JSONMap{}
        }</span> else<span class="cov8" title="1"> {
                t.Metadata = *aux.Metadata
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// TribeMember represents a user's membership in a tribe
type TribeMember struct {
        BaseModel
        TribeID        uuid.UUID      `json:"tribe_id" db:"tribe_id"`
        UserID         uuid.UUID      `json:"user_id" db:"user_id"`
        MembershipType MembershipType `json:"membership_type" db:"membership_type"`
        DisplayName    string         `json:"display_name" db:"display_name"`
        ExpiresAt      *time.Time     `json:"expires_at,omitempty" db:"expires_at"`
        Metadata       JSONMap        `json:"metadata,omitempty" db:"metadata"`
        User           *User          `json:"user,omitempty" db:"-"`
}

// Validate performs validation on the tribe member
func (tm *TribeMember) Validate() error <span class="cov8" title="1">{
        if err := tm.BaseModel.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if tm.TribeID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: tribe_id is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if tm.UserID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: user_id is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if err := tm.MembershipType.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if tm.DisplayName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: display_name is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if tm.MembershipType == MembershipGuest </span><span class="cov8" title="1">{
                if tm.ExpiresAt == nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: guest membership requires expiration date", ErrInvalidInput)
                }</span>
                <span class="cov8" title="1">if tm.ExpiresAt.Before(time.Now()) </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: expiration date cannot be in the past", ErrInvalidInput)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// TribeRepository defines the interface for tribe data operations
type TribeRepository interface {
        // Basic CRUD operations
        Create(tribe *Tribe) error
        GetByID(id uuid.UUID) (*Tribe, error)
        Update(tribe *Tribe) error
        Delete(id uuid.UUID) error
        List(offset, limit int) ([]*Tribe, error)

        // Member management
        AddMember(tribeID, userID uuid.UUID, memberType MembershipType, expiresAt *time.Time, invitedBy *uuid.UUID) error
        UpdateMember(tribeID, userID uuid.UUID, memberType MembershipType, expiresAt *time.Time) error
        RemoveMember(tribeID, userID uuid.UUID) error
        GetMembers(tribeID uuid.UUID) ([]*TribeMember, error)
        GetUserTribes(userID uuid.UUID) ([]*Tribe, error)

        // Queries
        GetByType(tribeType TribeType, offset, limit int) ([]*Tribe, error)
        Search(query string, offset, limit int) ([]*Tribe, error)
        GetExpiredGuestMemberships() ([]*TribeMember, error)
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package models

import (
        "encoding/json"
        "fmt"
        "time"

        "database/sql/driver"

        "github.com/google/uuid"
)

// VisibilityType defines who can see a resource
type VisibilityType string

const (
        VisibilityPrivate VisibilityType = "private" // Only visible to owner
        VisibilityShared  VisibilityType = "shared"  // Visible to specific tribes/users
        VisibilityPublic  VisibilityType = "public"  // Visible to everyone
)

func (v VisibilityType) Validate() error <span class="cov8" title="1">{
        switch v </span>{
        case VisibilityPrivate, VisibilityShared, VisibilityPublic:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: invalid visibility type: %s", ErrInvalidInput, v)</span>
        }
}

// OwnerType defines what type of entity owns a resource
type OwnerType string

const (
        OwnerTypeUser  OwnerType = "user"
        OwnerTypeTribe OwnerType = "tribe"
)

func (o OwnerType) Validate() error <span class="cov8" title="1">{
        switch o </span>{
        case OwnerTypeUser, OwnerTypeTribe:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: invalid owner type: %s", ErrInvalidInput, o)</span>
        }
}

// BaseModel contains common fields for all models
type BaseModel struct {
        ID        uuid.UUID  `json:"id" db:"id"`
        CreatedAt time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt time.Time  `json:"updated_at" db:"updated_at"`
        DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
        Version   int        `json:"version" db:"version"`
}

// Validate performs basic validation on the base model
func (b *BaseModel) Validate() error <span class="cov8" title="1">{
        if b.ID == uuid.Nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: id is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if b.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: created_at is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if b.UpdatedAt.IsZero() </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: updated_at is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if b.DeletedAt != nil &amp;&amp; b.DeletedAt.Before(b.CreatedAt) </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: deleted_at cannot be before created_at", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if b.Version &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: version must be at least 1", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Location represents a physical location that can be referenced in activities
type Location struct {
        BaseModel
        Name        string  `json:"name" db:"name"`
        Address     string  `json:"address" db:"address"`
        Latitude    float64 `json:"latitude" db:"latitude"`
        Longitude   float64 `json:"longitude" db:"longitude"`
        GoogleMapID string  `json:"google_map_id,omitempty" db:"google_map_id"`
        Metadata    JSONMap `json:"metadata,omitempty" db:"metadata"`
}

// Validate performs validation on the location
func (l *Location) Validate() error <span class="cov8" title="1">{
        if err := l.BaseModel.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if l.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: name is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.Address == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: address is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.Latitude &lt; -90 || l.Latitude &gt; 90 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: latitude must be between -90 and 90", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if l.Longitude &lt; -180 || l.Longitude &gt; 180 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: longitude must be between -180 and 180", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MenuParams represents parameters for generating a menu from lists
type MenuParams struct {
        ListIDs      []uuid.UUID            `json:"list_ids"`
        Count        int                    `json:"count"`
        Filters      map[string]interface{} `json:"filters,omitempty"`
        ExcludeItems []uuid.UUID            `json:"exclude_items,omitempty"`
}

// Validate performs validation on the menu parameters
func (m *MenuParams) Validate() error <span class="cov8" title="1">{
        if len(m.ListIDs) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: at least one list ID is required", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">if m.Count &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: count must be positive", ErrInvalidInput)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// JSONMap is a type alias for map[string]interface{} that implements database scanning
type JSONMap map[string]interface{}

// Scan implements the sql.Scanner interface
func (m *JSONMap) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                *m = make(JSONMap) // Always initialize to empty map, never nil
                return nil
        }</span>

        <span class="cov8" title="1">var bytes []byte
        switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                bytes = v</span>
        case string:<span class="cov8" title="1">
                bytes = []byte(v)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("%w: unsupported JSONMap scan type: %T", ErrInvalidInput, value)</span>
        }

        // Handle empty string/bytes as empty map
        <span class="cov8" title="1">if len(bytes) == 0 </span><span class="cov8" title="1">{
                *m = make(JSONMap)
                return nil
        }</span>

        // Parse JSON into map
        <span class="cov8" title="1">var result map[string]interface{}
        if err := json.Unmarshal(bytes, &amp;result); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: invalid JSON data: %v", ErrInvalidInput, err)
        }</span>

        // Convert any []interface{} to []string where appropriate
        <span class="cov8" title="1">for key, value := range result </span><span class="cov8" title="1">{
                if arr, ok := value.([]interface{}); ok </span><span class="cov8" title="1">{
                        strArr := make([]string, len(arr))
                        for i, v := range arr </span><span class="cov8" title="1">{
                                strArr[i] = fmt.Sprint(v)
                        }</span>
                        <span class="cov8" title="1">result[key] = strArr</span>
                }
        }

        <span class="cov8" title="1">*m = result
        return nil</span>
}

// Value implements the driver.Valuer interface
func (m JSONMap) Value() (driver.Value, error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Convert any []string back to []interface{} for consistent JSON encoding
        <span class="cov8" title="1">converted := make(map[string]interface{})
        for key, value := range m </span><span class="cov8" title="1">{
                if strArr, ok := value.([]string); ok </span><span class="cov8" title="1">{
                        interfaceArr := make([]interface{}, len(strArr))
                        for i, v := range strArr </span><span class="cov8" title="1">{
                                interfaceArr[i] = v
                        }</span>
                        <span class="cov8" title="1">converted[key] = interfaceArr</span>
                } else<span class="cov8" title="1"> {
                        converted[key] = value
                }</span>
        }

        <span class="cov8" title="1">return json.Marshal(converted)</span>
}

// MarshalJSON implements the json.Marshaler interface
func (m JSONMap) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return []byte("null"), nil
        }</span>
        <span class="cov8" title="1">return json.Marshal(map[string]interface{}(m))</span>
}

// UnmarshalJSON implements the json.Unmarshaler interface
func (m *JSONMap) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: JSONMap is nil", ErrInvalidInput)
        }</span>

        // Handle null JSON value
        <span class="cov8" title="1">if string(data) == "null" </span><span class="cov8" title="1">{
                *m = make(JSONMap)
                return nil
        }</span>

        // Parse JSON into temporary map
        <span class="cov8" title="1">var raw map[string]interface{}
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: invalid JSON data: %v", ErrInvalidInput, err)
        }</span>

        // Convert any []interface{} to []string where appropriate
        <span class="cov8" title="1">for key, value := range raw </span><span class="cov8" title="1">{
                if arr, ok := value.([]interface{}); ok </span><span class="cov8" title="1">{
                        strArr := make([]string, len(arr))
                        for i, v := range arr </span><span class="cov8" title="1">{
                                strArr[i] = fmt.Sprint(v)
                        }</span>
                        <span class="cov8" title="1">raw[key] = strArr</span>
                }
        }

        <span class="cov8" title="1">*m = raw
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
