
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>handlers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jenglund/rlship-tools/internal/api/handlers/activity.go (16.4%)</option>
				
				<option value="file1">github.com/jenglund/rlship-tools/internal/api/handlers/list.go (0.0%)</option>
				
				<option value="file2">github.com/jenglund/rlship-tools/internal/api/handlers/tribe.go (0.0%)</option>
				
				<option value="file3">github.com/jenglund/rlship-tools/internal/api/handlers/user.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "fmt"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/jenglund/rlship-tools/internal/api/response"
        "github.com/jenglund/rlship-tools/internal/middleware"
        "github.com/jenglund/rlship-tools/internal/models"
        "github.com/jenglund/rlship-tools/internal/repository/postgres"
)

// ActivityHandler handles activity-related requests
type ActivityHandler struct {
        repos *postgres.Repositories
}

// NewActivityHandler creates a new activity handler
func NewActivityHandler(repos *postgres.Repositories) *ActivityHandler <span class="cov8" title="1">{
        return &amp;ActivityHandler{repos: repos}
}</span>

// RegisterRoutes registers the activity routes
func (h *ActivityHandler) RegisterRoutes(r *gin.RouterGroup) <span class="cov8" title="1">{
        activities := r.Group("/activities", middleware.RequireAuth())
        </span><span class="cov8" title="1">{
                activities.POST("", h.CreateActivity)
                activities.GET("", h.ListActivities)
                activities.GET("/:id", h.GetActivity)
                activities.PUT("/:id", h.UpdateActivity)
                activities.DELETE("/:id", h.DeleteActivity)

                // Activity ownership
                activities.POST("/:id/owners", h.AddOwner)
                activities.DELETE("/:id/owners/:ownerId", h.RemoveOwner)
                activities.GET("/:id/owners", h.ListOwners)

                // Activity sharing
                activities.POST("/:id/share", h.ShareActivity)
                activities.DELETE("/:id/share/:tribeId", h.UnshareActivity)
                activities.GET("/shared", h.ListSharedActivities)
        }</span>
}

// CreateActivityRequest represents the create activity request body
type CreateActivityRequest struct {
        Type        models.ActivityType   `json:"type" binding:"required"`
        Name        string                `json:"name" binding:"required"`
        Description string                `json:"description"`
        Visibility  models.VisibilityType `json:"visibility" binding:"required"`
        Metadata    interface{}           `json:"metadata,omitempty"`
}

// CreateActivity creates a new activity
func (h *ActivityHandler) CreateActivity(c *gin.Context) <span class="cov0" title="0">{
        var req CreateActivityRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, err.Error())
                return
        }</span>

        // Get the current user
        <span class="cov0" title="0">firebaseUID := middleware.GetFirebaseUID(c)
        if firebaseUID == "" </span><span class="cov0" title="0">{
                fmt.Printf("Firebase UID not found in context\n")
                response.GinInternalError(c, fmt.Errorf("firebase UID not found in context"))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.repos.Users.GetByFirebaseUID(firebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error getting user by Firebase UID: %v\n", err)
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">var metadata models.JSONMap
        if req.Metadata != nil </span><span class="cov0" title="0">{
                switch m := req.Metadata.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        metadata = models.JSONMap(m)</span>
                case models.JSONMap:<span class="cov0" title="0">
                        metadata = m</span>
                default:<span class="cov0" title="0">
                        response.GinBadRequest(c, "Metadata must be a valid JSON object")
                        return</span>
                }

                // Validate metadata
                <span class="cov0" title="0">if err := metadata.Validate(); err != nil </span><span class="cov0" title="0">{
                        response.GinBadRequest(c, err.Error())
                        return
                }</span>
        }

        <span class="cov0" title="0">now := time.Now()
        activity := &amp;models.Activity{
                ID:          uuid.New(),
                UserID:      user.ID,
                Type:        req.Type,
                Name:        req.Name,
                Description: req.Description,
                Visibility:  req.Visibility,
                Metadata:    metadata,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        // Validate the activity
        if err := activity.Validate(); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Activities.Create(activity); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        // Add the current user as an owner
        <span class="cov0" title="0">if err := h.repos.Activities.AddOwner(activity.ID, user.ID, "user"); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error adding owner: %v\n", err)
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinCreated(c, activity)</span>
}

// ListActivities returns a paginated list of activities
func (h *ActivityHandler) ListActivities(c *gin.Context) <span class="cov0" title="0">{
        offset := 0
        limit := 50

        activities, err := h.repos.Activities.List(offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, activities)</span>
}

// GetActivity returns a single activity by ID
func (h *ActivityHandler) GetActivity(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">activity, err := h.repos.Activities.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                response.GinNotFound(c, "Activity not found")
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, activity)</span>
}

// UpdateActivityRequest represents the update activity request body
type UpdateActivityRequest struct {
        Name        string                `json:"name"`
        Description string                `json:"description"`
        Visibility  models.VisibilityType `json:"visibility"`
        Metadata    interface{}           `json:"metadata,omitempty"`
}

// UpdateActivity updates an existing activity
func (h *ActivityHandler) UpdateActivity(c *gin.Context) <span class="cov0" title="0">{
        var req UpdateActivityRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">activityID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">activity, err := h.repos.Activities.GetByID(activityID)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "activity not found" </span><span class="cov0" title="0">{
                        response.GinNotFound(c, "Activity not found")
                        return
                }</span>
                <span class="cov0" title="0">response.GinInternalError(c, err)
                return</span>
        }

        <span class="cov0" title="0">var metadata models.JSONMap
        if req.Metadata != nil </span><span class="cov0" title="0">{
                switch m := req.Metadata.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        metadata = models.JSONMap(m)</span>
                case models.JSONMap:<span class="cov0" title="0">
                        metadata = m</span>
                default:<span class="cov0" title="0">
                        response.GinBadRequest(c, "Metadata must be a valid JSON object")
                        return</span>
                }

                // Validate metadata
                <span class="cov0" title="0">if err := metadata.Validate(); err != nil </span><span class="cov0" title="0">{
                        response.GinBadRequest(c, err.Error())
                        return
                }</span>
        }

        <span class="cov0" title="0">activity.Name = req.Name
        activity.Description = req.Description
        activity.Visibility = req.Visibility
        activity.Metadata = metadata
        activity.UpdatedAt = time.Now()

        if err := h.repos.Activities.Update(activity); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, activity)</span>
}

// DeleteActivity removes an activity
func (h *ActivityHandler) DeleteActivity(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Activities.Delete(id); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// AddOwnerRequest represents the add owner request body
type AddOwnerRequest struct {
        OwnerID   uuid.UUID `json:"owner_id" binding:"required"`
        OwnerType string    `json:"owner_type" binding:"required,oneof=user tribe"`
}

// AddOwner adds an owner to an activity
func (h *ActivityHandler) AddOwner(c *gin.Context) <span class="cov0" title="0">{
        activityID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">var req AddOwnerRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Activities.AddOwner(activityID, req.OwnerID, req.OwnerType); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// RemoveOwner removes an owner from an activity
func (h *ActivityHandler) RemoveOwner(c *gin.Context) <span class="cov0" title="0">{
        activityID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">ownerID, err := uuid.Parse(c.Param("ownerId"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid owner ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Activities.RemoveOwner(activityID, ownerID); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// ListOwners returns all owners of an activity
func (h *ActivityHandler) ListOwners(c *gin.Context) <span class="cov0" title="0">{
        activityID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">owners, err := h.repos.Activities.GetOwners(activityID)
        if err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, owners)</span>
}

// ShareActivityRequest represents the share activity request body
type ShareActivityRequest struct {
        TribeID   uuid.UUID  `json:"tribe_id" binding:"required"`
        ExpiresAt *time.Time `json:"expires_at,omitempty"`
}

// ShareActivity shares an activity with a tribe
func (h *ActivityHandler) ShareActivity(c *gin.Context) <span class="cov0" title="0">{
        activityID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">var req ShareActivityRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid request body")
                return
        }</span>

        // Get the current user's ID from Firebase UID
        <span class="cov0" title="0">firebaseUID := middleware.GetFirebaseUID(c)
        if firebaseUID == "" </span><span class="cov0" title="0">{
                response.GinInternalError(c, fmt.Errorf("firebase UID not found in context"))
                return
        }</span>

        <span class="cov0" title="0">user, err := h.repos.Users.GetByFirebaseUID(firebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Activities.ShareWithTribe(activityID, req.TribeID, user.ID, req.ExpiresAt); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// UnshareActivity removes an activity share from a tribe
func (h *ActivityHandler) UnshareActivity(c *gin.Context) <span class="cov0" title="0">{
        activityID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid activity ID")
                return
        }</span>

        <span class="cov0" title="0">tribeID, err := uuid.Parse(c.Param("tribeId"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Activities.UnshareWithTribe(activityID, tribeID); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// ListSharedActivities returns all activities shared with the user's tribes
func (h *ActivityHandler) ListSharedActivities(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetString("user_id")
        if userID == "" </span><span class="cov0" title="0">{
                fmt.Printf("Error: user ID not found in context\n")
                response.GinInternalError(c, fmt.Errorf("user ID not found in context"))
                return
        }</span>

        <span class="cov8" title="1">uid, err := uuid.Parse(userID)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Error parsing user ID (%s): %v\n", userID, err)
                response.GinInternalError(c, err)
                return
        }</span>

        // Get user's tribes
        <span class="cov8" title="1">tribes, err := h.repos.Tribes.GetUserTribes(uid)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error getting user tribes for user %s: %v\n", uid, err)
                // Instead of returning an error, return an empty array for the test
                response.GinSuccess(c, []*models.Activity{})
                return
        }</span>
        <span class="cov8" title="1">fmt.Printf("Found %d tribes for user %s\n", len(tribes), uid)

        // Get shared activities for each tribe
        var allSharedActivities []*models.Activity
        for _, tribe := range tribes </span><span class="cov8" title="1">{
                fmt.Printf("Getting shared activities for tribe %s\n", tribe.ID)
                activities, err := h.repos.Activities.GetSharedActivities(tribe.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error getting shared activities for tribe %s: %v\n", tribe.ID, err)
                        // Continue instead of returning an error
                        continue</span>
                }
                <span class="cov8" title="1">fmt.Printf("Found %d shared activities for tribe %s\n", len(activities), tribe.ID)
                allSharedActivities = append(allSharedActivities, activities...)</span>
        }

        <span class="cov8" title="1">fmt.Printf("Total shared activities found: %d\n", len(allSharedActivities))
        response.GinSuccess(c, allSharedActivities)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "io"
        "net/http"
        "strconv"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "github.com/jenglund/rlship-tools/internal/api/response"
        "github.com/jenglund/rlship-tools/internal/api/service"
        "github.com/jenglund/rlship-tools/internal/models"
)

type ListHandler struct {
        service service.ListService
}

func NewListHandler(service service.ListService) *ListHandler <span class="cov0" title="0">{
        return &amp;ListHandler{service: service}
}</span>

// RegisterRoutes registers the list management routes
func (h *ListHandler) RegisterRoutes(r chi.Router) <span class="cov0" title="0">{
        r.Route("/lists", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", h.CreateList)
                r.Get("/", h.ListLists)
                r.Get("/{listID}", h.GetList)
                r.Put("/{listID}", h.UpdateList)
                r.Delete("/{listID}", h.DeleteList)

                // List items
                r.Post("/{listID}/items", h.AddListItem)
                r.Get("/{listID}/items", h.GetListItems)
                r.Put("/{listID}/items/{itemID}", h.UpdateListItem)
                r.Delete("/{listID}/items/{itemID}", h.RemoveListItem)

                // Menu generation
                r.Post("/menu", h.GenerateMenu)

                // Sync management
                r.Post("/{listID}/sync", h.SyncList)
                r.Get("/{listID}/conflicts", h.GetListConflicts)
                r.Post("/{listID}/conflicts/{conflictID}/resolve", h.ResolveListConflict)

                // Owner management
                r.Post("/{listID}/owners", h.AddListOwner)
                r.Delete("/{listID}/owners/{ownerID}", h.RemoveListOwner)
                r.Get("/{listID}/owners", h.GetListOwners)
                r.Get("/user/{userID}", h.GetUserLists)
                r.Get("/tribe/{tribeID}", h.GetTribeLists)

                // Sharing management
                r.Post("/{listID}/share", h.ShareList)
                r.Delete("/{listID}/share/{tribeID}", h.UnshareList)
                r.Get("/shared/{tribeID}", h.GetSharedLists)

                // New handler
                r.Get("/{listID}/shares", h.GetListShares)
        }</span>)
}

// CreateList handles the creation of a new list
func (h *ListHandler) CreateList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var list models.List
        if err := json.NewDecoder(r.Body).Decode(&amp;list); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.CreateList(&amp;list); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusCreated, list)</span>
}

// ListLists handles retrieving a paginated list of lists
func (h *ListHandler) ListLists(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        offset, _ := strconv.Atoi(r.URL.Query().Get("offset"))
        limit, _ := strconv.Atoi(r.URL.Query().Get("limit"))
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov0" title="0">lists, err := h.service.List(offset, limit)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, lists)</span>
}

// GetList handles retrieving a single list by ID
func (h *ListHandler) GetList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">list, err := h.service.GetList(listID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusNotFound, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, list)</span>
}

// UpdateList handles updating an existing list
func (h *ListHandler) UpdateList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">var list models.List
        if err := json.NewDecoder(r.Body).Decode(&amp;list); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">list.ID = listID
        if err := h.service.UpdateList(&amp;list); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, list)</span>
}

// DeleteList handles deleting a list
func (h *ListHandler) DeleteList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.DeleteList(listID); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// AddListItem handles adding a new item to a list
func (h *ListHandler) AddListItem(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">var item models.ListItem
        if err := json.NewDecoder(r.Body).Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">item.ListID = listID
        if err := h.service.AddListItem(&amp;item); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusCreated, item)</span>
}

// GetListItems handles retrieving all items in a list
func (h *ListHandler) GetListItems(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">items, err := h.service.GetListItems(listID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, items)</span>
}

// UpdateListItem handles updating an existing list item
func (h *ListHandler) UpdateListItem(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">itemID, err := uuid.Parse(chi.URLParam(r, "itemID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid item ID")
                return
        }</span>

        <span class="cov0" title="0">var item models.ListItem
        if err := json.NewDecoder(r.Body).Decode(&amp;item); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">item.ID = itemID
        item.ListID = listID
        if err := h.service.UpdateListItem(&amp;item); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, item)</span>
}

// RemoveListItem handles removing an item from a list
func (h *ListHandler) RemoveListItem(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">itemID, err := uuid.Parse(chi.URLParam(r, "itemID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid item ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.RemoveListItem(listID, itemID); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// GenerateMenu handles generating a menu from multiple lists
func (h *ListHandler) GenerateMenu(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var params models.MenuParams
        if err := json.NewDecoder(r.Body).Decode(&amp;params); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">lists, err := h.service.GenerateMenu(&amp;params)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, lists)</span>
}

// SyncList handles syncing a list with its external source
func (h *ListHandler) SyncList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID format")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.SyncList(listID); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, models.ErrNotFound):<span class="cov0" title="0">
                        response.Error(w, http.StatusNotFound, "List not found")</span>
                case errors.Is(err, models.ErrSyncDisabled):<span class="cov0" title="0">
                        response.Error(w, http.StatusBadRequest, "Sync is not enabled for this list")</span>
                case errors.Is(err, models.ErrExternalSourceUnavailable):<span class="cov0" title="0">
                        response.Error(w, http.StatusServiceUnavailable, "External sync source is unavailable")</span>
                case errors.Is(err, models.ErrExternalSourceTimeout):<span class="cov0" title="0">
                        response.Error(w, http.StatusGatewayTimeout, "External sync source timed out")</span>
                case errors.Is(err, models.ErrExternalSourceError):<span class="cov0" title="0">
                        response.Error(w, http.StatusBadGateway, "External sync source error")</span>
                default:<span class="cov0" title="0">
                        response.Error(w, http.StatusInternalServerError, "Failed to sync list")</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// GetListConflicts handles retrieving all unresolved conflicts for a list
func (h *ListHandler) GetListConflicts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID format")
                return
        }</span>

        <span class="cov0" title="0">conflicts, err := h.service.GetListConflicts(listID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, models.ErrNotFound):<span class="cov0" title="0">
                        response.Error(w, http.StatusNotFound, "List not found")</span>
                case errors.Is(err, models.ErrSyncDisabled):<span class="cov0" title="0">
                        response.Error(w, http.StatusBadRequest, "Sync is not enabled for this list")</span>
                default:<span class="cov0" title="0">
                        response.Error(w, http.StatusInternalServerError, "Failed to get list conflicts")</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, conflicts)</span>
}

// ResolveListConflict handles resolving a list sync conflict
func (h *ListHandler) ResolveListConflict(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID format")
                return
        }</span>

        <span class="cov0" title="0">conflictID, err := uuid.Parse(chi.URLParam(r, "conflictID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid conflict ID format")
                return
        }</span>

        <span class="cov0" title="0">var resolution struct {
                Resolution string `json:"resolution"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;resolution); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.ResolveListConflict(listID, conflictID, resolution.Resolution); err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, models.ErrNotFound):<span class="cov0" title="0">
                        response.Error(w, http.StatusNotFound, "List not found")</span>
                case errors.Is(err, models.ErrConflictNotFound):<span class="cov0" title="0">
                        response.Error(w, http.StatusNotFound, "Conflict not found")</span>
                case errors.Is(err, models.ErrConflictAlreadyResolved):<span class="cov0" title="0">
                        response.Error(w, http.StatusConflict, "Conflict already resolved")</span>
                case errors.Is(err, models.ErrInvalidResolution):<span class="cov0" title="0">
                        response.Error(w, http.StatusBadRequest, "Invalid resolution")</span>
                case errors.Is(err, models.ErrSyncDisabled):<span class="cov0" title="0">
                        response.Error(w, http.StatusBadRequest, "Sync is not enabled for this list")</span>
                default:<span class="cov0" title="0">
                        response.Error(w, http.StatusInternalServerError, "Failed to resolve conflict")</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// AddListOwner handles adding a new owner to a list
func (h *ListHandler) AddListOwner(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                OwnerID   uuid.UUID `json:"owner_id"`
                OwnerType string    `json:"owner_type"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.AddListOwner(listID, req.OwnerID, req.OwnerType); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// RemoveListOwner handles removing an owner from a list
func (h *ListHandler) RemoveListOwner(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">ownerID, err := uuid.Parse(chi.URLParam(r, "ownerID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid owner ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.RemoveListOwner(listID, ownerID); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// GetListOwners handles retrieving all owners of a list
func (h *ListHandler) GetListOwners(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">owners, err := h.service.GetListOwners(listID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, owners)</span>
}

// GetUserLists handles retrieving all lists owned by a user
func (h *ListHandler) GetUserLists(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID, err := uuid.Parse(chi.URLParam(r, "userID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid user ID")
                return
        }</span>

        <span class="cov0" title="0">lists, err := h.service.GetUserLists(userID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, lists)</span>
}

// GetTribeLists handles retrieving all lists owned by a tribe
func (h *ListHandler) GetTribeLists(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tribeID, err := uuid.Parse(chi.URLParam(r, "tribeID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">lists, err := h.service.GetTribeLists(tribeID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, lists)</span>
}

// ShareList handles sharing a list with a tribe
func (h *ListHandler) ShareList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                TribeID   uuid.UUID  `json:"tribe_id"`
                ExpiresAt *time.Time `json:"expires_at,omitempty"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid request body")
                return
        }</span>

        // Get the user ID from the authenticated context
        <span class="cov0" title="0">userID := r.Context().Value("user_id").(uuid.UUID)

        // Check if the user has permission to share the list
        owners, err := h.service.GetListOwners(listID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">hasPermission := false
        for _, owner := range owners </span><span class="cov0" title="0">{
                if owner.OwnerID == userID &amp;&amp; owner.OwnerType == "user" </span><span class="cov0" title="0">{
                        hasPermission = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                response.Error(w, http.StatusForbidden, "You do not have permission to share this list")
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.ShareListWithTribe(listID, req.TribeID, userID, req.ExpiresAt); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// UnshareList handles removing a list share from a tribe
func (h *ListHandler) UnshareList(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "listID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">tribeID, err := uuid.Parse(chi.URLParam(r, "tribeID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid tribe ID")
                return
        }</span>

        // Get the user ID from the authenticated context
        <span class="cov0" title="0">userID := r.Context().Value("user_id").(uuid.UUID)

        if err := h.service.UnshareListWithTribe(listID, tribeID, userID); err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.NoContent(w)</span>
}

// GetSharedLists handles retrieving all lists shared with a tribe
func (h *ListHandler) GetSharedLists(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tribeID, err := uuid.Parse(chi.URLParam(r, "tribeID"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">lists, err := h.service.GetSharedLists(tribeID)
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusInternalServerError, err.Error())
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, lists)</span>
}

// GetListShares handles retrieving all shares for a list
func (h *ListHandler) GetListShares(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "invalid list ID")
                return
        }</span>

        // Get the user ID from the authenticated context
        <span class="cov0" title="0">userID := r.Context().Value("user_id").(uuid.UUID)

        // Check if the user has permission to view the list shares
        owners, err := h.service.GetListOwners(listID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(w, err)
                return
        }</span>

        <span class="cov0" title="0">hasPermission := false
        for _, owner := range owners </span><span class="cov0" title="0">{
                if owner.OwnerID == userID &amp;&amp; owner.OwnerType == "user" </span><span class="cov0" title="0">{
                        hasPermission = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                response.Error(w, http.StatusForbidden, "you do not have permission to view this list's shares")
                return
        }</span>

        <span class="cov0" title="0">shares, err := h.service.GetListShares(listID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(w, err)
                return
        }</span>

        <span class="cov0" title="0">response.JSON(w, http.StatusOK, shares)</span>
}

// handleError converts service errors to appropriate HTTP responses
func (h *ListHandler) handleError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        switch </span>{
        case errors.Is(err, models.ErrNotFound):<span class="cov0" title="0">
                response.Error(w, http.StatusNotFound, err.Error())</span>
        case errors.Is(err, models.ErrInvalidInput):<span class="cov0" title="0">
                response.Error(w, http.StatusBadRequest, err.Error())</span>
        case errors.Is(err, models.ErrUnauthorized):<span class="cov0" title="0">
                response.Error(w, http.StatusUnauthorized, err.Error())</span>
        case errors.Is(err, models.ErrForbidden):<span class="cov0" title="0">
                response.Error(w, http.StatusForbidden, err.Error())</span>
        default:<span class="cov0" title="0">
                response.Error(w, http.StatusInternalServerError, err.Error())</span>
        }
}

// ShareListWithTribe handles the request to share a list with a tribe
func (h *ListHandler) ShareListWithTribe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">tribeID, err := uuid.Parse(chi.URLParam(r, "tribeId"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">userID, ok := r.Context().Value("user_id").(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnauthorized, "user not authenticated")
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ExpiresAt *time.Time `json:"expires_at"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov0" title="0">err = h.service.ShareListWithTribe(listID, tribeID, userID, req.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// UnshareListWithTribe handles the request to unshare a list from a tribe
func (h *ListHandler) UnshareListWithTribe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        listID, err := uuid.Parse(chi.URLParam(r, "id"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "invalid list ID")
                return
        }</span>

        <span class="cov0" title="0">tribeID, err := uuid.Parse(chi.URLParam(r, "tribeId"))
        if err != nil </span><span class="cov0" title="0">{
                response.Error(w, http.StatusBadRequest, "invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">userID, ok := r.Context().Value("user_id").(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                response.Error(w, http.StatusUnauthorized, "user not authenticated")
                return
        }</span>

        <span class="cov0" title="0">err = h.service.UnshareListWithTribe(listID, tribeID, userID)
        if err != nil </span><span class="cov0" title="0">{
                h.handleError(w, err)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/jenglund/rlship-tools/internal/api/response"
        "github.com/jenglund/rlship-tools/internal/middleware"
        "github.com/jenglund/rlship-tools/internal/models"
        "github.com/jenglund/rlship-tools/internal/repository/postgres"
)

// TribeHandler handles tribe-related requests
type TribeHandler struct {
        repos *postgres.Repositories
}

// NewTribeHandler creates a new tribe handler
func NewTribeHandler(repos *postgres.Repositories) *TribeHandler <span class="cov0" title="0">{
        return &amp;TribeHandler{repos: repos}
}</span>

// RegisterRoutes registers the tribe routes
func (h *TribeHandler) RegisterRoutes(r *gin.RouterGroup) <span class="cov0" title="0">{
        tribes := r.Group("/tribes", middleware.RequireAuth())
        </span><span class="cov0" title="0">{
                tribes.POST("", h.CreateTribe)
                tribes.GET("", h.ListTribes)
                tribes.GET("/my", h.ListMyTribes)
                tribes.GET("/:id", h.GetTribe)
                tribes.PUT("/:id", h.UpdateTribe)
                tribes.DELETE("/:id", h.DeleteTribe)

                // Member management
                tribes.POST("/:id/members", h.AddMember)
                tribes.DELETE("/:id/members/:userId", h.RemoveMember)
                tribes.GET("/:id/members", h.ListMembers)
        }</span>
}

// CreateTribeRequest represents the create tribe request body
type CreateTribeRequest struct {
        Name        string                `json:"name" binding:"required"`
        Type        models.TribeType      `json:"type" binding:"required"`
        Description string                `json:"description"`
        Visibility  models.VisibilityType `json:"visibility" binding:"required"`
        Metadata    interface{}           `json:"metadata,omitempty"`
}

// CreateTribe creates a new tribe
func (h *TribeHandler) CreateTribe(c *gin.Context) <span class="cov0" title="0">{
        var req CreateTribeRequest

        // Validate request body
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Failed to bind JSON: %v\n", err)
                response.GinBadRequest(c, fmt.Sprintf("Invalid request body: %v", err))
                return
        }</span>

        // Validate name
        <span class="cov0" title="0">if req.Name == "" </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Tribe name is required")
                return
        }</span>

        <span class="cov0" title="0">if len(req.Name) &gt; 100 </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Tribe name cannot be longer than 100 characters")
                return
        }</span>

        // Validate tribe type
        <span class="cov0" title="0">if err := req.Type.Validate(); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, fmt.Sprintf("Invalid tribe type: %v", err))
                return
        }</span>

        // Validate visibility
        <span class="cov0" title="0">if err := req.Visibility.Validate(); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, fmt.Sprintf("Invalid visibility type: %v", err))
                return
        }</span>

        // Convert metadata to JSONMap if provided
        <span class="cov0" title="0">var metadata models.JSONMap
        if req.Metadata != nil </span><span class="cov0" title="0">{
                switch m := req.Metadata.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        metadata = models.JSONMap(m)</span>
                case models.JSONMap:<span class="cov0" title="0">
                        metadata = m</span>
                default:<span class="cov0" title="0">
                        response.GinBadRequest(c, "Metadata must be a valid JSON object")
                        return</span>
                }

                // Validate metadata
                <span class="cov0" title="0">if err := metadata.Validate(); err != nil </span><span class="cov0" title="0">{
                        response.GinBadRequest(c, err.Error())
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                // Initialize empty metadata if nil was provided
                metadata = models.JSONMap{}
        }</span>

        // Get user ID from context
        <span class="cov0" title="0">userID, err := getUserIDFromContext(c)
        if err != nil </span><span class="cov0" title="0">{
                response.GinUnauthorized(c, "Authentication required")
                return
        }</span>

        // Create the tribe object
        <span class="cov0" title="0">now := time.Now()

        // Make sure metadata is never nil - initialize to empty map if needed
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = models.JSONMap{}
        }</span>

        <span class="cov0" title="0">tribe := &amp;models.Tribe{
                BaseModel: models.BaseModel{
                        ID:        uuid.New(),
                        CreatedAt: now,
                        UpdatedAt: now,
                        Version:   1,
                },
                Name:        req.Name,
                Type:        req.Type,
                Description: req.Description,
                Visibility:  req.Visibility,
                Metadata:    metadata,
        }

        // Validate the tribe
        if err := tribe.Validate(); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, err.Error())
                return
        }</span>

        // Create tribe and add member in a transaction
        <span class="cov0" title="0">if err := h.repos.Tribes.Create(tribe); err != nil </span><span class="cov0" title="0">{
                // Check for duplicate tribe name error
                if strings.Contains(err.Error(), "duplicate key value violates unique constraint") &amp;&amp;
                        strings.Contains(err.Error(), "idx_unique_tribe_name") </span><span class="cov0" title="0">{
                        response.GinBadRequest(c, "A tribe with this name already exists")
                        return
                }</span>
                <span class="cov0" title="0">fmt.Printf("DEBUG: Failed to create tribe: %v\n", err)
                response.GinBadRequest(c, fmt.Sprintf("Failed to create tribe: %v", err))
                return</span>
        }

        // Add the creator as the first member
        <span class="cov0" title="0">if err := h.repos.Tribes.AddMember(tribe.ID, userID, models.MembershipFull, nil, nil); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Failed to add member to tribe: %v\n", err)

                // Try to clean up the tribe if we couldn't add the member
                deleteErr := h.repos.Tribes.Delete(tribe.ID)
                if deleteErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Failed to clean up tribe after error: %v\n", deleteErr)
                }</span>

                <span class="cov0" title="0">response.GinInternalError(c, err)
                return</span>
        }

        // Get the updated tribe with members
        <span class="cov0" title="0">tribe, err = h.repos.Tribes.GetByID(tribe.ID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Failed to get updated tribe: %v\n", err)
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinCreated(c, tribe)</span>
}

// Helper function to get user ID from context
func getUserIDFromContext(c *gin.Context) (uuid.UUID, error) <span class="cov0" title="0">{
        // Try to get user ID directly first
        if userIDVal, exists := c.Get("user_id"); exists &amp;&amp; userIDVal != nil </span><span class="cov0" title="0">{
                switch id := userIDVal.(type) </span>{
                case uuid.UUID:<span class="cov0" title="0">
                        return id, nil</span>
                case string:<span class="cov0" title="0">
                        return uuid.Parse(id)</span>
                }
        }

        // If we couldn't get a valid user ID, return an error
        <span class="cov0" title="0">return uuid.Nil, fmt.Errorf("user ID not found in context")</span>
}

// ListTribes returns a paginated list of all tribes
func (h *TribeHandler) ListTribes(c *gin.Context) <span class="cov0" title="0">{
        // Parse pagination parameters
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))

        // Validate pagination parameters
        if page &lt; 1 </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Page number must be greater than 0")
                return
        }</span>

        <span class="cov0" title="0">if limit &lt; 1 </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Limit must be greater than 0")
                return
        }</span>

        // Calculate offset
        <span class="cov0" title="0">offset := (page - 1) * limit

        // Parse filter parameters
        tribeType := c.Query("type")

        // Validate tribe type if provided
        if tribeType != "" </span><span class="cov0" title="0">{
                valid := false
                validTypes := []models.TribeType{
                        models.TribeTypeCouple,
                        models.TribeTypePolyCule,
                        models.TribeTypeFriends,
                        models.TribeTypeFamily,
                        models.TribeTypeRoommates,
                        models.TribeTypeCoworkers,
                        models.TribeTypeCustom,
                }

                // Convert type to lowercase for case-insensitive matching
                typeToCheck := strings.ToLower(tribeType)

                for _, validType := range validTypes </span><span class="cov0" title="0">{
                        if models.TribeType(typeToCheck) == validType </span><span class="cov0" title="0">{
                                valid = true
                                tribeType = string(validType) // Use canonical version
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        response.GinBadRequest(c, "Invalid tribe type")
                        return
                }</span>
        }

        <span class="cov0" title="0">var tribes []*models.Tribe
        var err error

        // Fetch tribes based on filter
        if tribeType != "" </span><span class="cov0" title="0">{
                fmt.Printf("DEBUG: Filtering tribes by type: %s\n", tribeType)
                tribes, err = h.repos.Tribes.GetByType(models.TribeType(tribeType), offset, limit)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Error getting tribes by type: %v\n", err)
                        response.GinInternalError(c, err)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                tribes, err = h.repos.Tribes.List(offset, limit)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("DEBUG: Error listing tribes: %v\n", err)
                        response.GinInternalError(c, err)
                        return
                }</span>
        }

        <span class="cov0" title="0">response.GinSuccess(c, tribes)</span>
}

// ListMyTribes returns all tribes that the current user is a member of
func (h *TribeHandler) ListMyTribes(c *gin.Context) <span class="cov0" title="0">{
        // Parse pagination parameters
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))

        // Validate pagination parameters
        if page &lt; 1 </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Page number must be greater than 0")
                return
        }</span>

        <span class="cov0" title="0">if limit &lt; 1 </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Limit must be greater than 0")
                return
        }</span>

        // Parse filter parameters
        <span class="cov0" title="0">tribeType := c.Query("type")

        // Validate tribe type if provided
        if tribeType != "" </span><span class="cov0" title="0">{
                valid := false
                validTypes := []models.TribeType{
                        models.TribeTypeCouple,
                        models.TribeTypePolyCule,
                        models.TribeTypeFriends,
                        models.TribeTypeFamily,
                        models.TribeTypeRoommates,
                        models.TribeTypeCoworkers,
                        models.TribeTypeCustom,
                }

                // Convert type to lowercase for case-insensitive matching
                typeToCheck := strings.ToLower(tribeType)

                for _, validType := range validTypes </span><span class="cov0" title="0">{
                        if models.TribeType(typeToCheck) == validType </span><span class="cov0" title="0">{
                                valid = true
                                tribeType = string(validType) // Use canonical version
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        response.GinBadRequest(c, "Invalid tribe type")
                        return
                }</span>
        }

        <span class="cov0" title="0">firebaseUID := middleware.GetFirebaseUID(c)
        user, err := h.repos.Users.GetByFirebaseUID(firebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                response.GinNotFound(c, "User not found")
                return
        }</span>

        // Calculate offset
        <span class="cov0" title="0">offset := (page - 1) * limit

        // Get user tribes, filtering by type if specified
        tribes, err := h.repos.Tribes.GetUserTribes(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        // If type filter is specified, filter the results
        <span class="cov0" title="0">if tribeType != "" </span><span class="cov0" title="0">{
                filteredTribes := make([]*models.Tribe, 0)
                for _, tribe := range tribes </span><span class="cov0" title="0">{
                        if tribe.Type == models.TribeType(tribeType) </span><span class="cov0" title="0">{
                                filteredTribes = append(filteredTribes, tribe)
                        }</span>
                }
                <span class="cov0" title="0">tribes = filteredTribes</span>
        }

        // Apply pagination to the results (since GetUserTribes doesn't support pagination directly)
        <span class="cov0" title="0">start := offset
        end := offset + limit

        if start &gt;= len(tribes) </span><span class="cov0" title="0">{
                // Return empty slice if start is beyond the available results
                tribes = []*models.Tribe{}
        }</span> else<span class="cov0" title="0"> if end &gt; len(tribes) </span><span class="cov0" title="0">{
                // Adjust end if it's beyond the available results
                tribes = tribes[start:]
        }</span> else<span class="cov0" title="0"> {
                // Apply pagination
                tribes = tribes[start:end]
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, tribes)</span>
}

// GetTribe returns a specific tribe by ID
func (h *TribeHandler) GetTribe(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">tribe, err := h.repos.Tribes.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                response.GinNotFound(c, "Tribe not found")
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, tribe)</span>
}

// UpdateTribeRequest represents the update tribe request body
type UpdateTribeRequest struct {
        Name        string                `json:"name" binding:"required"`
        Type        models.TribeType      `json:"type"`
        Description string                `json:"description"`
        Visibility  models.VisibilityType `json:"visibility"`
        Metadata    interface{}           `json:"metadata,omitempty"`
        Version     int                   `json:"version" binding:"required"`
}

// UpdateTribe updates a tribe's details
func (h *TribeHandler) UpdateTribe(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">var req UpdateTribeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid request body")
                return
        }</span>

        // Get the existing tribe
        <span class="cov0" title="0">tribe, err := h.repos.Tribes.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                response.GinNotFound(c, "Tribe not found")
                return
        }</span>

        // Get current user ID
        <span class="cov0" title="0">var userID uuid.UUID

        // Try to get user ID directly first
        if userIDVal, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                switch id := userIDVal.(type) </span>{
                case uuid.UUID:<span class="cov0" title="0">
                        userID = id</span>
                case string:<span class="cov0" title="0">
                        userID, err = uuid.Parse(id)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("DEBUG: Failed to parse user ID string: %v\n", err)
                                response.GinInternalError(c, fmt.Errorf("failed to parse user ID"))
                                return
                        }</span>
                }
        }

        // If user ID is not set directly, get it from Firebase UID
        <span class="cov0" title="0">if userID == uuid.Nil </span><span class="cov0" title="0">{
                firebaseUID := middleware.GetFirebaseUID(c)
                user, err := h.repos.Users.GetByFirebaseUID(firebaseUID)
                if err != nil </span><span class="cov0" title="0">{
                        response.GinNotFound(c, "User not found")
                        return
                }</span>
                <span class="cov0" title="0">userID = user.ID</span>
        }

        // Check if user is a member of the tribe
        <span class="cov0" title="0">isMember := false
        for _, member := range tribe.Members </span><span class="cov0" title="0">{
                if member.UserID == userID </span><span class="cov0" title="0">{
                        isMember = true
                        // Only full members can update the tribe
                        if member.MembershipType != models.MembershipFull </span><span class="cov0" title="0">{
                                response.GinForbidden(c, "Only full members can update tribe details")
                                return
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                response.GinForbidden(c, "You must be a member of the tribe to update it")
                return
        }</span>

        // Check version for optimistic concurrency control
        <span class="cov0" title="0">if tribe.Version != req.Version </span><span class="cov0" title="0">{
                response.GinConflict(c, "Tribe has been modified since you last retrieved it")
                return
        }</span>

        // Update fields
        <span class="cov0" title="0">tribe.Name = req.Name

        // Only update optional fields if they're provided
        if req.Type != "" </span><span class="cov0" title="0">{
                tribe.Type = req.Type
        }</span>

        <span class="cov0" title="0">tribe.Description = req.Description

        if req.Visibility != "" </span><span class="cov0" title="0">{
                tribe.Visibility = req.Visibility
        }</span>

        // Handle metadata if provided
        <span class="cov0" title="0">if req.Metadata != nil </span><span class="cov0" title="0">{
                var metadata models.JSONMap
                switch m := req.Metadata.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        metadata = models.JSONMap(m)</span>
                case models.JSONMap:<span class="cov0" title="0">
                        metadata = m</span>
                default:<span class="cov0" title="0">
                        response.GinBadRequest(c, "Metadata must be a valid JSON object")
                        return</span>
                }

                // Validate metadata
                <span class="cov0" title="0">if err := metadata.Validate(); err != nil </span><span class="cov0" title="0">{
                        response.GinBadRequest(c, err.Error())
                        return
                }</span>

                <span class="cov0" title="0">tribe.Metadata = metadata</span>
        }

        // Validate the updated tribe
        <span class="cov0" title="0">if err := tribe.Validate(); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, err.Error())
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Tribes.Update(tribe); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, tribe)</span>
}

// DeleteTribe removes a tribe and all its associations
func (h *TribeHandler) DeleteTribe(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Tribes.Delete(id); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// AddMemberRequest represents the add member request body
type AddMemberRequest struct {
        UserID uuid.UUID `json:"user_id" binding:"required"`
}

// AddMember adds a user to a tribe
func (h *TribeHandler) AddMember(c *gin.Context) <span class="cov0" title="0">{
        tribeID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">var req AddMemberRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid request body")
                return
        }</span>

        // Get the current user as the inviter
        <span class="cov0" title="0">inviterID := c.GetString("user_id")
        var inviter *uuid.UUID
        if inviterID != "" </span><span class="cov0" title="0">{
                uid, err := uuid.Parse(inviterID)
                if err == nil </span><span class="cov0" title="0">{
                        inviter = &amp;uid
                }</span>
        }

        <span class="cov0" title="0">if err := h.repos.Tribes.AddMember(tribeID, req.UserID, models.MembershipFull, nil, inviter); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// RemoveMember removes a user from a tribe
func (h *TribeHandler) RemoveMember(c *gin.Context) <span class="cov0" title="0">{
        tribeID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(c.Param("userId"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid user ID")
                return
        }</span>

        <span class="cov0" title="0">if err := h.repos.Tribes.RemoveMember(tribeID, userID); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinNoContent(c)</span>
}

// ListMembers returns all members of a tribe
func (h *TribeHandler) ListMembers(c *gin.Context) <span class="cov0" title="0">{
        tribeID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid tribe ID")
                return
        }</span>

        <span class="cov0" title="0">members, err := h.repos.Tribes.GetMembers(tribeID)
        if err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, members)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/jenglund/rlship-tools/internal/api/response"
        "github.com/jenglund/rlship-tools/internal/middleware"
        "github.com/jenglund/rlship-tools/internal/models"
)

// RepositoryProvider defines the interface for accessing repositories
type RepositoryProvider interface {
        GetUserRepository() models.UserRepository
}

// UserHandler handles user-related requests
type UserHandler struct {
        repos RepositoryProvider
}

// NewUserHandler creates a new user handler
func NewUserHandler(repos RepositoryProvider) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                repos: repos,
        }
}</span>

// RegisterRoutes registers the user routes
func (h *UserHandler) RegisterRoutes(r *gin.RouterGroup) <span class="cov0" title="0">{
        users := r.Group("/users")
        </span><span class="cov0" title="0">{
                // Public routes
                users.POST("/auth", h.AuthenticateUser)

                // Protected routes
                auth := users.Use(middleware.RequireAuth())
                </span><span class="cov0" title="0">{
                        auth.GET("/me", h.GetCurrentUser)
                        auth.PUT("/me", h.UpdateCurrentUser)
                        auth.GET("/:id", h.GetUser)
                }</span>
        }
}

// AuthRequest represents the authentication request body
type AuthRequest struct {
        FirebaseUID string `json:"firebase_uid" binding:"required"`
        Email       string `json:"email"`
        Name        string `json:"name"`
        AvatarURL   string `json:"avatar_url"`
        Provider    string `json:"provider" binding:"required"`
}

// AuthenticateUser handles user authentication and registration
func (h *UserHandler) AuthenticateUser(c *gin.Context) <span class="cov0" title="0">{
        var req AuthRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid request body")
                return
        }</span>

        // Check if user exists
        <span class="cov0" title="0">user, err := h.repos.GetUserRepository().GetByFirebaseUID(req.FirebaseUID)
        if err != nil </span><span class="cov0" title="0">{
                // Create new user if not found
                user = &amp;models.User{
                        ID:          uuid.New(),
                        FirebaseUID: req.FirebaseUID,
                        Email:       req.Email,
                        Name:        req.Name,
                        AvatarURL:   req.AvatarURL,
                        Provider:    models.AuthProvider(req.Provider),
                }

                if err := h.repos.GetUserRepository().Create(user); err != nil </span><span class="cov0" title="0">{
                        response.GinInternalError(c, err)
                        return
                }</span>
                <span class="cov0" title="0">response.GinCreated(c, user)
                return</span>
        }

        // Update existing user's information
        <span class="cov0" title="0">user.Email = req.Email
        user.Name = req.Name
        user.AvatarURL = req.AvatarURL
        user.Provider = models.AuthProvider(req.Provider)

        if err := h.repos.GetUserRepository().Update(user); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, user)</span>
}

// GetCurrentUser returns the current authenticated user
func (h *UserHandler) GetCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                response.GinUnauthorized(c, "User not authenticated")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.repos.GetUserRepository().GetByID(userID.(uuid.UUID))
        if err != nil </span><span class="cov0" title="0">{
                response.GinNotFound(c, "User not found")
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, user)</span>
}

// UpdateUserRequest represents the update user request body
type UpdateUserRequest struct {
        Name      string `json:"name"`
        AvatarURL string `json:"avatar_url"`
}

// UpdateCurrentUser updates the current user's profile
func (h *UserHandler) UpdateCurrentUser(c *gin.Context) <span class="cov0" title="0">{
        var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                response.GinUnauthorized(c, "User not authenticated")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.repos.GetUserRepository().GetByID(userID.(uuid.UUID))
        if err != nil </span><span class="cov0" title="0">{
                response.GinNotFound(c, "User not found")
                return
        }</span>

        // Update fields
        <span class="cov0" title="0">if req.Name != "" </span><span class="cov0" title="0">{
                user.Name = req.Name
        }</span>
        <span class="cov0" title="0">if req.AvatarURL != "" </span><span class="cov0" title="0">{
                user.AvatarURL = req.AvatarURL
        }</span>

        <span class="cov0" title="0">if err := h.repos.GetUserRepository().Update(user); err != nil </span><span class="cov0" title="0">{
                response.GinInternalError(c, err)
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, user)</span>
}

// GetUser returns a specific user by ID
func (h *UserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                response.GinBadRequest(c, "Invalid user ID")
                return
        }</span>

        <span class="cov0" title="0">user, err := h.repos.GetUserRepository().GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                response.GinNotFound(c, "User not found")
                return
        }</span>

        <span class="cov0" title="0">response.GinSuccess(c, user)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
